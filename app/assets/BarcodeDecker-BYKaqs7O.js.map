{"version":3,"file":"BarcodeDecker-BYKaqs7O.js","sources":["../../node_modules/.pnpm/@tanstack+virtual-core@3.13.6/node_modules/@tanstack/virtual-core/dist/esm/utils.js","../../node_modules/.pnpm/@tanstack+virtual-core@3.13.6/node_modules/@tanstack/virtual-core/dist/esm/index.js","../../node_modules/.pnpm/@tanstack+vue-virtual@3.13.6_vue@3.5.12_typescript@5.6.3_/node_modules/@tanstack/vue-virtual/dist/esm/index.js","../../src/pages/cell/BookList.tsx","../../src/components/Button/Button.tsx","../../src/components/barcode/Barcode.tsx","../../src/components/barcode/BarcodeDecker.tsx"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n","import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(element.getBoundingClientRect());\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n      if (!offsetAndAlign) return;\n      const [offset, align] = offsetAndAlign;\n      this._scrollToOffset(offset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.elementsCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [latestOffset] = notUndefined(\n              this.getOffsetForIndex(index, align)\n            );\n            if (!approxEqual(latestOffset, this.getScrollOffset())) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n","import { elementScroll, observeElementOffset, observeElementRect, windowScroll, observeWindowOffset, observeWindowRect, Virtualizer } from \"@tanstack/virtual-core\";\nexport * from \"@tanstack/virtual-core\";\nimport { computed, unref, shallowRef, watch, triggerRef, onScopeDispose } from \"vue\";\nfunction useVirtualizerBase(options) {\n  const virtualizer = new Virtualizer(unref(options));\n  const state = shallowRef(virtualizer);\n  const cleanup = virtualizer._didMount();\n  watch(\n    () => unref(options).getScrollElement(),\n    (el) => {\n      if (el) {\n        virtualizer._willUpdate();\n      }\n    },\n    {\n      immediate: true\n    }\n  );\n  watch(\n    () => unref(options),\n    (options2) => {\n      virtualizer.setOptions({\n        ...options2,\n        onChange: (instance, sync) => {\n          var _a;\n          triggerRef(state);\n          (_a = options2.onChange) == null ? void 0 : _a.call(options2, instance, sync);\n        }\n      });\n      virtualizer._willUpdate();\n      triggerRef(state);\n    },\n    {\n      immediate: true\n    }\n  );\n  onScopeDispose(cleanup);\n  return state;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase(\n    computed(() => ({\n      observeElementRect,\n      observeElementOffset,\n      scrollToFn: elementScroll,\n      ...unref(options)\n    }))\n  );\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase(\n    computed(() => ({\n      getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n      observeElementRect: observeWindowRect,\n      observeElementOffset: observeWindowOffset,\n      scrollToFn: windowScroll,\n      initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n      ...unref(options)\n    }))\n  );\n}\nexport {\n  useVirtualizer,\n  useWindowVirtualizer\n};\n//# sourceMappingURL=index.js.map\n","/**\n * @file 图书列表\n * @author Yangholmes 2025-04-07\n */\n\nimport { computed, defineComponent, PropType, ref, toRefs, watch } from 'vue';\nimport cn from 'classnames';\n\nimport { useVirtualizer } from '@tanstack/vue-virtual';\nimport { useI18n } from 'vue-i18n';\n\nimport SvgIcon from '@/components/svgIcon/SvgIcon';\n\nimport { BookInCellRawCover, getBookCover } from '../book/utils';\nimport db from '@/services/db';\n\nimport { NPopconfirm, NRate } from 'naive-ui';\n\nimport styles from './bookList.module.less';\n\nexport default defineComponent({\n  name: 'BookList',\n  props: {\n    data: {\n      type: Array as PropType<BookInCellRawCover[]>,\n      default: () => ([])\n    },\n    onPreviewBook: {\n      type: Function as PropType<(book: BookInCellRawCover) => void>,\n    },\n    onEditBook: {\n      type: Function as PropType<(book: BookInCellRawCover) => void>,\n    },\n    onDeleteBook: {\n      type: Function as PropType<(book: BookInCellRawCover) => void>,\n    }\n  },\n  setup(props) {\n    const { data } = toRefs(props);\n\n    const { t } = useI18n({ useScope: 'global' });\n\n    const coversSrc = ref<string[]>([]);\n    watch(() => data.value, (newVal) => {\n      db.book.queryCoversById(newVal.map(v => v.covers[0] || '')).then(res => {\n        coversSrc.value = res.map((cover, index) => getBookCover(cover?.file, newVal[index].title));\n      });\n    }, { immediate: true });\n\n    const holdingTarget = ref<number>();\n    const holdingTouch = ref(false);\n    const timer = ref<number>();\n    const resetTouch = () => {\n      holdingTarget.value = undefined;\n      holdingTouch.value = false;\n      window.clearTimeout(timer.value as number);\n      timer.value = undefined;\n      popShow.value = false;\n      popPosition.value = [-999, -999];\n    };\n\n    const onTouchstart = (e: TouchEvent) => {\n      // 非单指操作跳过\n      if (e.touches.length !== 1) {\n        return;\n      }\n      // 点击工具栏不需要变更状态\n      const target = (e.target as HTMLDivElement)?.dataset?.target;\n      if (target === 'tools') {\n        return;\n      }\n      const indexStr = (e.target as HTMLDivElement)?.dataset?.index || '';\n      const index = Number.parseInt(indexStr, 10);\n      const needReset =\n        // 状态异常，重置状态\n        holdingTouch.value ||\n        // 取消选中态\n        holdingTarget.value !== undefined;\n      if (needReset) {\n        resetTouch();\n      } else {\n        if (!Number.isNaN(index)) {\n          holdingTouch.value = true;\n          timer.value = window.setTimeout(() => {\n            if (holdingTouch.value) {\n              holdingTouch.value = false;\n              holdingTarget.value = index;\n            } else {\n              onTouchmove();\n            }\n          }, 5e2);\n        }\n      }\n    };\n\n    const onTouchmove = () => {\n      if (holdingTarget.value === undefined && holdingTouch.value) {\n        resetTouch();\n      }\n    };\n\n    const onTouchend = () => {\n      onTouchmove();\n    };\n\n    const onTouchcancel = () => {\n      onTouchmove();\n    };\n\n    const popPosition = ref<[number, number]>([-999, -999]);\n    const popShow = ref(false);\n    const tools = [\n      {\n        name: 'preview',\n        icon: '👀️',\n        cb: () => {\n          if (holdingTarget.value !== undefined) {\n            const book = data.value[holdingTarget.value];\n            props.onPreviewBook?.(book);\n          }\n          resetTouch();\n        }\n      },\n      {\n        name: 'edit',\n        icon: <SvgIcon name=\"pencil\" />,\n        cb: () => {\n          if (holdingTarget.value !== undefined) {\n            const book = data.value[holdingTarget.value];\n            props.onEditBook?.(book);\n          }\n          resetTouch();\n        },\n      },\n      {\n        name: 'delete',\n        icon: <SvgIcon name=\"delete\" />,\n        cb: (e: MouseEvent) => {\n          const { x, y } = e;\n          popPosition.value = [x, y];\n          popShow.value = true;\n        },\n      }\n    ];\n    const onClick = (e: MouseEvent) => {\n      const toolName = (e.target as HTMLDivElement)?.dataset?.tool;\n      const tool = tools.find(t => t.name === toolName);\n      if (tool) {\n        tool.cb(e);\n      }\n    };\n\n    const rootRef = ref<HTMLElement | null>(null);\n    const rowVirtualizerOptions = computed(() => {\n      return {\n        count: data.value.length,\n        getScrollElement: () => rootRef.value,\n        estimateSize: () => 120,\n        overscan: 3,\n        gap: 16\n      };\n    });\n    const rowVirtualizer = useVirtualizer(rowVirtualizerOptions);\n    const virtualRows = computed(() => rowVirtualizer.value.getVirtualItems());\n    const totalSize = computed(() => rowVirtualizer.value.getTotalSize());\n\n    return () => (<>\n      <div\n        class={cn(styles['book-list'])}\n        ref={rootRef}\n        onTouchstart={onTouchstart}\n        onTouchmove={onTouchmove}\n        onTouchend={onTouchend}\n        onTouchcancel={onTouchcancel}\n        onClick={onClick}\n      >\n        <div\n          class={cn(styles['virtual-list'])}\n          style={{\n            '--list-height': `${totalSize.value}px`\n          }}\n        >\n          {virtualRows.value.map((virtualRow) => {\n            const { index, key, size, start } = virtualRow;\n            const book = data.value[index];\n            return (\n              <div\n                class={cn(styles.book)}\n                key={String(key)}\n                style={{\n                  '--book-height': `${size}px`,\n                  '--book-start': `${start}px`,\n                }}\n              >\n                <div\n                  class={cn(styles.mask, {\n                    [styles.picked]: holdingTarget.value === index\n                  })}\n                  data-index={index}\n                >\n                  <div class={cn(styles.tools)}>\n                    {tools.map(tool => (<div\n                      class={cn(styles.tool)}\n                      data-target=\"tools\"\n                      data-tool={tool.name}\n                    >\n                      {tool.icon}\n                    </div>))}\n                  </div>\n                </div>\n                <div class={cn(styles.info)}>\n                  <div\n                    class={cn(styles.cover)}\n                    style={{ backgroundImage: `url(${coversSrc.value[index]})` }}\n                  />\n                  <div class={cn(styles.abstract)}>\n                    <div class={cn(styles['full-text'], styles.title)}>\n                      {book.title}\n                    </div>\n                    <div class={cn(styles['full-text'])}>\n                      {book.authors ? book.authors?.join(' / ') : t('pages.cell.bookList.unknownAuthor')}\n                    </div>\n                    <div class={cn(styles['full-text'])}>\n                      {book.publishers ? book.publishers?.join(' / ') : t('pages.cell.bookList.unknownPublisher')}\n                    </div>\n                    <div>isbn: {book.isbn}</div>\n                    <NRate\n                      count={5}\n                      value={book.rating}\n                      readonly\n                      size=\"small\"\n                    />\n                  </div>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n      {/* 删除确认气泡 */}\n      <NPopconfirm\n        showIcon={false}\n        placement=\"left-end\"\n        trigger=\"manual\"\n        positiveText={t('common.delete')}\n        negativeText={t('common.forgetIt')}\n        positive-button-props={{\n          type: 'error',\n        }}\n        onPositiveClick={() => {\n          if (holdingTarget.value !== undefined) {\n            const book = data.value[holdingTarget.value];\n            props.onDeleteBook?.(book);\n          }\n          resetTouch();\n        }}\n        onNegativeClick={() => {\n          popShow.value = false;\n        }}\n        onClickoutside={() => {\n          popShow.value = false;\n        }}\n        x={popPosition.value?.[0]}\n        y={popPosition.value?.[1]}\n        show={popShow.value}\n      >\n        {t('common.deleteConfirm')}\n      </NPopconfirm>\n    </>);\n  }\n});\n","/**\n * @file 按钮组件\n * @author Yangholmes 2025-04-29\n */\n\nimport { defineComponent, PropType } from 'vue';\n\nimport cn from 'classnames';\n\nimport styles from './button.module.less';\n\nexport default defineComponent({\n  name: 'Button',\n  props: {\n    text: {\n      type: Boolean,\n      default: false\n    },\n    circle: {\n      type: Boolean,\n      default: false\n    },\n    type: {\n      type: String,\n      default: 'default'\n    },\n    onClick: {\n      type: Function as PropType<(e: MouseEvent) => void>\n    }\n  },\n  setup(props, { slots }) {\n    const onClick = (e: MouseEvent) => {\n      props.onClick?.(e);\n    };\n\n    return () => <div\n      class={cn(styles.button, styles[props.type], {\n        [styles.circle]: props.circle,\n      })}\n      onClick={onClick}\n    >\n      {slots.default?.()}\n    </div>;\n  }\n});\n","/**\n * @file 条形码识别\n * @author Yangholmes 2024-10-25\n */\n\nimport { defineComponent, onMounted, onUnmounted, PropType, ref, watch } from 'vue';\nimport cn from 'classnames';\n\nimport BcrWorker from './barcodeRecognize.worker?worker';\nimport { BarcodeResult } from './barcodeRecognize.worker';\n\nimport styles from './barcode.module.less';\n\n/** 摄像头类型 前置 / 后置 */\nexport type CameraTypes = 'front' | 'rear'\n\nconst cameras: {\n  [key in CameraTypes]: MediaStreamConstraints['video']\n} = {\n  front: { facingMode: 'user' },\n  rear: { facingMode: 'environment' }\n};\n\nexport default defineComponent({\n  name: 'Barcode',\n  props: {\n    cameraType: {\n      type: String as PropType<CameraTypes>,\n      default: 'rear',\n    },\n    onDevicesDetect: {\n      type: Function as PropType<(devices: MediaDeviceInfo[]) => void>,\n    },\n    onBarcodeDetect: {\n      type: Function as PropType<(result: string) => Promise<boolean>>,\n    }\n  },\n  setup(props) {\n    const videoRef = ref<HTMLVideoElement>();\n    const streamRef = ref<MediaStream>();\n\n    const pause = ref(false);\n\n    const initDevices = () => {\n      return navigator.mediaDevices.enumerateDevices().then(devices => {\n        console.log(devices);\n        const videoInputDevices = devices.filter(device => device.kind === 'videoinput');\n        props.onDevicesDetect?.(videoInputDevices);\n        return videoInputDevices;\n      });\n    };\n\n    const initVideo = () => {\n      navigator.mediaDevices.getUserMedia({ video: cameras[props.cameraType], audio: false })\n        .then((stream) => {\n          if (!videoRef.value) {\n            return Promise.reject();\n          }\n          streamRef.value = stream;\n          videoRef.value.srcObject = stream;\n          videoRef.value.play();\n          videoRef.value.onloadedmetadata = () => {\n            capture();\n          };\n        })\n        .catch((err) => {\n          console.error('Error accessing the camera: ' + err);\n        });\n    };\n\n    const clearVideo = () => {\n      if (streamRef.value) {\n        streamRef.value.getTracks().forEach((track) => {\n          track.stop();\n        });\n        streamRef.value = undefined;\n      }\n      if (videoRef.value) {\n        videoRef.value.pause();\n        videoRef.value.srcObject = null;\n      }\n      window.clearTimeout(timer.value);\n      timer.value = undefined;\n    };\n\n    const workerRef = ref<null | InstanceType<typeof BcrWorker>>(null);\n    const capture = () => {\n      if (!videoRef.value) {\n        return Promise.reject();\n      }\n      const width = videoRef.value.videoWidth;\n      const height = videoRef.value.videoHeight;\n\n      const canvas = new OffscreenCanvas(640, 640);\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas?.getContext('2d');\n      ctx?.drawImage(videoRef.value, 0, 0);\n      // canvas.convertToBlob().then(res => {\n      //   // console.log(res);\n      //   const url = URL.createObjectURL(res)\n      //   // console.log(url);\n      //   setTimeout(() => {\n      //     capture()\n      //   }, 5e3)\n      // })\n      const isReady =\n        width > 0 &&\n        height > 0 &&\n        ctx &&\n        !pause.value;\n      if (isReady && workerRef.value) {\n        const imageData = ctx.getImageData(0, 0, width, height);\n\n        workerRef.value.postMessage(imageData, [imageData.data.buffer]);\n\n        workerRef.value.onmessage = (e: MessageEvent<BarcodeResult>) => {\n          const { output, corners, result } = e.data;\n\n          // TODO 还可以继续优化\n          if (result) {\n            barcodeResult.value = result;\n            if (!pause.value) {\n              pause.value = true;\n              props.onBarcodeDetect?.(result).then(res => {\n                pause.value = res;\n              });\n            }\n          }\n\n          // let imageData = new ImageData(new Uint8ClampedArray(output), width, height);\n\n          const cc = canvasRef.value;\n          // const video = videoRef.value;\n          // video.width = width\n          // video.height = height\n          if (cc) {\n            cc.width = width;\n            cc.height = height;\n          }\n          const cctx = cc?.getContext('2d');\n          if (cctx) {\n            // cctx?.putImageData(imageData, 0, 0)\n\n            cctx.strokeStyle = 'red';\n            cctx.lineWidth = 2;\n            cctx.beginPath();\n            cctx.moveTo(corners[0], corners[1]);\n            for (let i = 2; i < corners.length; i += 2) {\n              cctx.lineTo(corners[i], corners[i + 1]);\n            }\n            cctx.closePath();\n            cctx.stroke();\n          }\n          capture();\n        };\n      }\n    };\n\n    const timer = ref<number>();\n    watch(() => pause.value, (val) => {\n      if (!val) {\n        // 增加延迟避免鬼畜\n        timer.value = window.setTimeout(() => {\n          capture();\n        }, 1e3);\n      }\n    });\n\n    watch(() => props.cameraType, () => {\n      clearVideo();\n      initVideo();\n    });\n\n    const barcodeResult = ref<string>('');\n    const canvasRef = ref<HTMLCanvasElement>();\n\n    onMounted(() => {\n      initDevices().then(() => {\n        initVideo();\n      });\n      workerRef.value = new BcrWorker();\n    });\n\n    onUnmounted(() => {\n      // 资源回收\n      workerRef.value?.terminate();\n      workerRef.value = null;\n      clearVideo();\n    });\n\n    return () => (<>\n      <div class={cn(styles.barcode)}>\n        <video ref={videoRef} playsinline />\n        <canvas ref={canvasRef} />\n      </div>\n    </>);\n  }\n});\n\n","/**\n * @file 条码扫描层，用于 double decker 第二层\n * @author Yangholmes 2025-04-29\n */\n\nimport { defineComponent, PropType, ref } from 'vue';\n\nimport BasicTopBar from '@/pages/layout/BasicTopBar';\nimport DeckerLayout from '@/pages/layout/DeckerLayout';\nimport Button from '../Button/Button';\nimport SvgIcon from '../svgIcon/SvgIcon';\nimport Barcode, { CameraTypes } from './Barcode';\n\nexport default defineComponent({\n  name: 'BarcodeDecker',\n  props: {\n    onBarcodeDetect: {\n      type: Function as PropType<(result: string) => Promise<boolean>>,\n    }\n  },\n  setup(props) {\n    const camera = ref<CameraTypes>('rear');\n\n    return () => <DeckerLayout fullWidth\n      style={{\n        backgroundColor: '#000'\n      }}\n      topBar={<BasicTopBar\n        leftSlots={[]}\n        rightSlots={[<Button\n          circle\n          onClick={() => {\n            camera.value = camera.value === 'rear' ? 'front' : 'rear';\n          }}\n        >\n          <SvgIcon name=\"cameraSwitch\" />\n        </Button>]}\n      />}\n    >\n      <Barcode cameraType={camera.value} onBarcodeDetect={props.onBarcodeDetect} />\n    </DeckerLayout>;\n  }\n});\n\n"],"names":["memo","getDeps","fn","opts","deps","result","memoizedFunction","_a","_b","_c","_d","depTime","newDeps","dep","index","resultTime","depEndTime","resultEndTime","resultFpsPercentage","pad","str","num","notUndefined","value","msg","approxEqual","a","b","debounce","targetWindow","ms","timeoutId","args","defaultKeyExtractor","defaultRangeExtractor","range","start","end","arr","i","observeElementRect","instance","cb","element","handler","rect","width","height","observer","entries","run","entry","box","addEventListenerOptions","supportsScrollend","observeElementOffset","offset","fallback","createHandler","isScrolling","horizontal","isRtl","endHandler","registerScrollendEvent","measureElement","elementScroll","adjustments","behavior","toOffset","Virtualizer","_ro","get","target","opts2","key","sync","d","scrollElement","cached","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","previousFurthestMeasurement","count","paddingStart","scrollMargin","getItemKey","enabled","itemSizeCache","item","min","furthestMeasurement","measuredSize","size","lane","outerSize","scrollOffset","lanes","calculateRange","startIndex","endIndex","rangeExtractor","overscan","node","attributeName","indexStr","prevNode","itemSize","delta","indexes","virtualItems","k","len","findNearestBinarySearch","align","scrollSizeProp","maxOffset","initialAlign","offsetAndAlign","latestOffset","endByLane","val","low","high","getCurrentValue","middle","currentValue","lastIndex","getOffset","endPerLane","pos","startPerLane","useVirtualizerBase","options","virtualizer","unref","state","shallowRef","cleanup","watch","el","options2","triggerRef","onScopeDispose","useVirtualizer","computed","_isSlot","s","Object","prototype","toString","call","_isVNode","defineComponent","name","props","data","type","Array","default","onPreviewBook","Function","onEditBook","onDeleteBook","setup","toRefs","t","useI18n","useScope","coversSrc","ref","newVal","db","book","queryCoversById","map","v","covers","then","res","cover","getBookCover","file","title","immediate","holdingTarget","holdingTouch","timer","resetTouch","undefined","window","clearTimeout","popShow","popPosition","onTouchstart","e","touches","length","dataset","Number","parseInt","isNaN","setTimeout","onTouchmove","onTouchend","onTouchcancel","tools","icon","_createVNode","SvgIcon","x","y","onClick","toolName","tool","find","rootRef","rowVirtualizerOptions","getScrollElement","estimateSize","gap","rowVirtualizer","virtualRows","getVirtualItems","totalSize","getTotalSize","_slot","_Fragment","cn","styles","virtualRow","String","mask","picked","info","backgroundImage","abstract","authors","join","publishers","_createTextVNode","isbn","NRate","rating","NPopconfirm","onPositiveClick","onNegativeClick","onClickoutside","text","Boolean","circle","slots","button","cameras","front","facingMode","rear","cameraType","onDevicesDetect","onBarcodeDetect","videoRef","streamRef","pause","initDevices","navigator","mediaDevices","enumerateDevices","devices","console","log","videoInputDevices","filter","device","kind","initVideo","getUserMedia","video","audio","stream","Promise","reject","srcObject","play","onloadedmetadata","capture","catch","err","error","clearVideo","getTracks","forEach","track","stop","workerRef","videoWidth","videoHeight","canvas","OffscreenCanvas","ctx","getContext","drawImage","imageData","getImageData","postMessage","buffer","onmessage","output","corners","barcodeResult","cc","canvasRef","cctx","strokeStyle","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","onMounted","BcrWorker","onUnmounted","terminate","barcode","camera","DeckerLayout","backgroundColor","BasicTopBar","Button","Barcode"],"mappings":"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","x_google_ignoreList":[0,1,2]}